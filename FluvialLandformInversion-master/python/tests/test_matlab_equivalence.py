"""Test Python implementation against MATLAB reference results.

This script compares Python outputs with MATLAB validation data generated by
matlab/generate_python_validation_data.m

Run this after generating MATLAB reference data to verify numerical equivalence.
"""

import numpy as np
import scipy.io as sio
import pytest
import sys
import os

# Add parent directory to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from fluvial_inversion import (
    calculate_chi,
    invert_block_uplift,
    findm_slope_area,
    calibrate_k_total_uplift,
    bootstrap_invert_block_uplift
)


class TestMATLABEquivalence:
    """Test Python implementation against MATLAB reference results."""

    @pytest.fixture
    def matlab_block_uplift_data(self):
        """Load MATLAB validation data for block uplift."""
        matlab_path = '../../matlab/matlab_validation_block_uplift.mat'
        if not os.path.exists(matlab_path):
            pytest.skip(
                "MATLAB validation data not found. "
                "Run matlab/generate_python_validation_data.m first."
            )
        return sio.loadmat(matlab_path)

    @pytest.fixture
    def matlab_parabola_data(self):
        """Load MATLAB validation data for parabola."""
        matlab_path = '../../matlab/matlab_validation_parabola.mat'
        if not os.path.exists(matlab_path):
            pytest.skip(
                "MATLAB validation data not found. "
                "Run matlab/generate_python_validation_data.m first."
            )
        return sio.loadmat(matlab_path)

    @pytest.fixture
    def block_uplift_raw_data(self):
        """Load raw block uplift data."""
        data_path = '../../matlab/BlockUpliftDataHighRes.mat'
        if not os.path.exists(data_path):
            pytest.skip("BlockUpliftDataHighRes.mat not found")

        mat_data = sio.loadmat(data_path)
        return {
            'x': mat_data['x'].flatten(),
            'y': mat_data['y'].flatten(),
            'z': mat_data['z'].flatten(),
            'area_array': mat_data['area_array'].flatten(),
            'rec_array': mat_data['rec_array'].flatten().astype(int) - 1,
            'slope_array': mat_data['slope_array'].flatten()
        }

    def test_findm_slope_area_equivalence(self, matlab_block_uplift_data, block_uplift_raw_data):
        """Test that FindmSlopeArea produces same m as MATLAB."""
        matlab_m = float(matlab_block_uplift_data['m_matlab'])
        matlab_R2 = float(matlab_block_uplift_data['R2_matlab'])

        # Run Python version
        python_m, lb, ub, python_R2 = findm_slope_area(
            block_uplift_raw_data['slope_array'],
            block_uplift_raw_data['area_array'],
            to_plot=False
        )

        print(f"\nFindmSlopeArea comparison:")
        print(f"  MATLAB: m = {matlab_m:.6f}, R² = {matlab_R2:.6f}")
        print(f"  Python: m = {python_m:.6f}, R² = {python_R2:.6f}")
        print(f"  Diff:   Δm = {abs(matlab_m - python_m):.2e}, ΔR² = {abs(matlab_R2 - python_R2):.2e}")

        # Test with tight tolerance
        np.testing.assert_allclose(python_m, matlab_m, rtol=1e-4, atol=1e-6,
                                   err_msg="Concavity index m differs from MATLAB")
        np.testing.assert_allclose(python_R2, matlab_R2, rtol=1e-3, atol=1e-4,
                                   err_msg="R² differs from MATLAB")

    def test_calculate_chi_equivalence(self, matlab_block_uplift_data, block_uplift_raw_data):
        """Test that CalculateChi produces same chi as MATLAB."""
        matlab_chi = matlab_block_uplift_data['chi'].flatten()
        matlab_m = float(matlab_block_uplift_data['m_matlab'])

        # Run Python version
        python_chi = calculate_chi(
            block_uplift_raw_data['x'],
            block_uplift_raw_data['y'],
            block_uplift_raw_data['rec_array'],
            block_uplift_raw_data['area_array'],
            matlab_m,
            A0=1.0
        )

        print(f"\nCalculateChi comparison:")
        print(f"  MATLAB: chi range = [{matlab_chi.min():.2f}, {matlab_chi.max():.2f}]")
        print(f"  Python: chi range = [{python_chi.min():.2f}, {python_chi.max():.2f}]")
        print(f"  Max diff: {np.max(np.abs(matlab_chi - python_chi)):.2e}")
        print(f"  Mean diff: {np.mean(np.abs(matlab_chi - python_chi)):.2e}")

        # Test with tight tolerance (should be nearly identical)
        np.testing.assert_allclose(python_chi, matlab_chi, rtol=1e-10, atol=1e-10,
                                   err_msg="Chi values differ from MATLAB")

    def test_invert_block_uplift_equivalence(self, matlab_block_uplift_data, block_uplift_raw_data):
        """Test that InvertBlockUplift produces same results as MATLAB."""
        matlab_Ustar = matlab_block_uplift_data['Ustar_matlab'].flatten()
        matlab_tstar = matlab_block_uplift_data['tstar_matlab'].flatten()
        matlab_misfit = float(matlab_block_uplift_data['Misfit_matlab'])

        gamma = float(matlab_block_uplift_data['gamma'])
        q = int(matlab_block_uplift_data['q'])

        # Use MATLAB chi for exact comparison
        chi = matlab_block_uplift_data['chi'].flatten()
        z = block_uplift_raw_data['z']

        # Run Python version
        python_Ustar, python_tstar, python_misfit = invert_block_uplift(
            chi, z, gamma, q, to_plot=False
        )

        print(f"\nInvertBlockUplift comparison (gamma={gamma}, q={q}):")
        print(f"  Misfit - MATLAB: {matlab_misfit:.6f}, Python: {python_misfit:.6f}, "
              f"Diff: {abs(matlab_misfit - python_misfit):.2e}")

        print(f"\n  Uplift rates (U*):")
        for i in range(len(matlab_Ustar)):
            diff = abs(matlab_Ustar[i] - python_Ustar[i])
            rel_diff = diff / abs(matlab_Ustar[i]) if matlab_Ustar[i] != 0 else 0
            print(f"    Interval {i+1}: MATLAB={matlab_Ustar[i]:.6f}, "
                  f"Python={python_Ustar[i]:.6f}, Diff={diff:.2e} ({rel_diff*100:.4f}%)")

        # Test with reasonable tolerances (may differ slightly due to numerical precision)
        np.testing.assert_allclose(python_Ustar, matlab_Ustar, rtol=1e-3, atol=1e-6,
                                   err_msg="Uplift rates differ from MATLAB")
        np.testing.assert_allclose(python_tstar, matlab_tstar, rtol=1e-10, atol=1e-10,
                                   err_msg="Time boundaries differ from MATLAB")
        np.testing.assert_allclose(python_misfit, matlab_misfit, rtol=1e-4, atol=1e-6,
                                   err_msg="Misfit differs from MATLAB")

    def test_calibrate_k_equivalence(self, matlab_block_uplift_data):
        """Test that CalibrateKTotalUplift produces same K as MATLAB."""
        matlab_K = float(matlab_block_uplift_data['K_matlab'])
        matlab_U = matlab_block_uplift_data['U_matlab'].flatten()
        matlab_t = matlab_block_uplift_data['t_matlab'].flatten()

        Ustar = matlab_block_uplift_data['Ustar_matlab'].flatten()
        tstar = matlab_block_uplift_data['tstar_matlab'].flatten()
        H = float(matlab_block_uplift_data['H'])
        t_H = float(matlab_block_uplift_data['t_H'])
        A0 = float(matlab_block_uplift_data['A0'])
        m = float(matlab_block_uplift_data['m_matlab'])

        # Run Python version
        python_K, python_U, python_t = calibrate_k_total_uplift(
            H, t_H, Ustar, tstar, A0, m, to_plot=False
        )

        print(f"\nCalibrateKTotalUplift comparison:")
        print(f"  K - MATLAB: {matlab_K:.6e}, Python: {python_K:.6e}, "
              f"Diff: {abs(matlab_K - python_K):.2e}")

        print(f"\n  Dimensional uplift rates [m/yr]:")
        for i in range(min(3, len(matlab_U))):  # Show first 3
            diff = abs(matlab_U[i] - python_U[i])
            print(f"    Interval {i+1}: MATLAB={matlab_U[i]:.6e}, "
                  f"Python={python_U[i]:.6e}, Diff={diff:.2e}")

        # Test K (should be nearly identical)
        np.testing.assert_allclose(python_K, matlab_K, rtol=1e-10, atol=1e-15,
                                   err_msg="Erodibility K differs from MATLAB")

        # Test dimensional rates
        np.testing.assert_allclose(python_U, matlab_U, rtol=1e-10, atol=1e-15,
                                   err_msg="Dimensional uplift rates differ from MATLAB")
        np.testing.assert_allclose(python_t, matlab_t, rtol=1e-10, atol=1e-15,
                                   err_msg="Dimensional times differ from MATLAB")

    def test_bootstrap_statistics(self, matlab_block_uplift_data, block_uplift_raw_data):
        """Test that bootstrap produces consistent statistics with MATLAB."""
        matlab_Ustar_mat = matlab_block_uplift_data['Ustar_mat_matlab']
        matlab_tstar_best = matlab_block_uplift_data['tstar_best_matlab'].flatten()

        chi = matlab_block_uplift_data['chi'].flatten()
        z = block_uplift_raw_data['z']
        gamma = float(matlab_block_uplift_data['gamma'])
        K = float(matlab_block_uplift_data['K_matlab'])

        # Use same parameters as MATLAB
        q_bootstrap = matlab_Ustar_mat.shape[1]

        # Run Python version with same seed
        python_Ustar_mat, python_tstar_best = bootstrap_invert_block_uplift(
            chi, z,
            gamma=gamma,
            q=q_bootstrap,
            percent_sample=0.8,
            num_iterations=20,
            K=K,
            to_plot=False,
            random_seed=42
        )

        print(f"\nBootstrap comparison:")
        print(f"  Iterations: MATLAB={matlab_Ustar_mat.shape[0]}, "
              f"Python={python_Ustar_mat.shape[0]}")

        # Compare mean and std of bootstrap distributions
        matlab_mean = np.mean(matlab_Ustar_mat, axis=0)
        python_mean = np.nanmean(python_Ustar_mat, axis=0)

        matlab_std = np.std(matlab_Ustar_mat, axis=0)
        python_std = np.nanstd(python_Ustar_mat, axis=0)

        print(f"\n  Mean uplift rates:")
        for i in range(len(matlab_mean)):
            print(f"    Interval {i+1}: MATLAB={matlab_mean[i]:.6f}, "
                  f"Python={python_mean[i]:.6f}")

        print(f"\n  Std uplift rates:")
        for i in range(len(matlab_std)):
            print(f"    Interval {i+1}: MATLAB={matlab_std[i]:.6f}, "
                  f"Python={python_std[i]:.6f}")

        # Note: Due to randomness, we can't expect exact match even with same seed
        # (MATLAB and Python RNGs are different). Just check that statistics are reasonable.
        # This is more of an integration test than exact equivalence.

        # Check that means are in same ballpark (within 50% is reasonable for random sampling)
        for i in range(len(matlab_mean)):
            assert abs(python_mean[i] - matlab_mean[i]) < abs(matlab_mean[i]) * 0.5, \
                f"Bootstrap mean for interval {i+1} differs significantly"


def print_summary():
    """Print summary of equivalence testing."""
    print("\n" + "="*70)
    print("  MATLAB-PYTHON EQUIVALENCE TEST SUMMARY")
    print("="*70)
    print("\nThis test suite compares Python implementation with MATLAB results.")
    print("\nTo generate MATLAB reference data:")
    print("  1. Open MATLAB")
    print("  2. cd matlab/")
    print("  3. Run: generate_python_validation_data")
    print("\nThen run: pytest tests/test_matlab_equivalence.py -v")
    print("="*70 + "\n")


if __name__ == "__main__":
    print_summary()
    pytest.main([__file__, "-v", "-s"])
